<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DT Evaluation Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <h1>Decision Transformer Evaluation Dashboard</h1>
  <div id="summary">
    <h2>Summary</h2>
    <div id="summary-table"></div>
    <div id="config-impact-table"></div>
    <div id="checkpoint-comparison"></div>
  </div>
  <div id="threshold-controls">
    <h3>Threshold toggles</h3>
    <div id="threshold-toggles"></div>
  </div>
  <div id="global-metrics" style="width:100%;height:400px;"></div>
  <div id="per-circle" style="width:100%;height:400px;"></div>
  <div id="calibration-performance">
    <h2>Calibration &amp; Performance Metrics</h2>
    <div id="calibration-ece" style="width:100%;height:300px;"></div>
    <div id="latency-metrics" style="width:100%;height:350px;"></div>
  </div>
  <div id="reward-presets">
    <h2>Reward preset analysis</h2>
    <div id="reward-presets-summary"></div>
    <div id="reward-presets-plot" style="width:100%;height:400px;"></div>
  </div>
  <script>
    const data = {"timestamps": ["2025-11-24T00:00:00Z", "2025-11-24T00:00:00Z"], "top1": [0.7, 0.8], "top3": [0.9, 0.95], "cont_mae": [0.1, 0.12], "calibration_error": [null, null], "latency_p50": [null, null], "latency_p95": [null, null], "latency_p99": [null, null], "per_circle": {"assessor": {"x": ["2025-11-24T00:00:00Z", "2025-11-24T00:00:00Z"], "y": [0.65, 0.65]}, "orchestrator": {"x": ["2025-11-24T00:00:00Z", "2025-11-24T00:00:00Z"], "y": [0.75, 0.75]}}, "top1_stats": {"min": 0.7, "p25": 0.725, "median": 0.75, "p75": 0.775, "p90": 0.79, "max": 0.8}, "top3_stats": {"min": 0.9, "p25": 0.9125, "median": 0.925, "p75": 0.9375, "p90": 0.945, "max": 0.95}, "cont_mae_stats": {"min": 0.1, "p25": 0.10500000000000001, "median": 0.11, "p75": 0.11499999999999999, "p90": 0.118, "max": 0.12}, "extra_metric_stats": {}, "per_circle_medians": {"orchestrator": 0.75, "assessor": 0.65}, "thresholds": {"staging": {"min_top1_accuracy": 0.4, "max_cont_mae": 0.5, "per_circle_min_top1": {"orchestrator": 0.35, "assessor": 0.35}}, "production": {"min_top1_accuracy": 0.7, "max_cont_mae": 0.15, "per_circle_min_top1": {"orchestrator": 0.7, "assessor": 0.7}}}, "recommendations": {"staging": {"min_top1_accuracy": 0.65, "max_cont_mae": 0.127}, "production": {"min_top1_accuracy": 0.75, "max_cont_mae": 0.11, "per_circle_min_top1_orchestrator": 0.75, "per_circle_min_top1_assessor": 0.65}}, "config_impact": {"staging": {"name": "staging", "pass_count": 2, "fail_count": 0, "pass_rate": 1.0, "failure_reasons": {}}, "production": {"name": "production", "pass_count": 0, "fail_count": 2, "pass_rate": 0.0, "failure_reasons": {"per_circle_min_top1[assessor]": 2}}, "dt_validation_thresholds_candidate.yaml": {"name": "dt_validation_thresholds_candidate.yaml", "pass_count": 0, "fail_count": 2, "pass_rate": 0.0, "failure_reasons": {"min_top1_accuracy": 2, "max_cont_mae": 2}}}, "checkpoint_summary": {"dt_model.pt": {"count": 2, "median_top1": 0.75, "median_cont_mae": 0.11}}, "checkpoints": [".goalie/dt_model.pt", ".goalie/dt_model.pt"], "checkpoint_names": ["dt_model.pt", "dt_model.pt"], "run_names": ["test-run", "test-run"], "reward_preset_analysis": {"trajectories_file": "/Users/shahroozbhopti/Documents/code/investing/agentic-flow/.goalie/trajectories.jsonl", "total_steps": 211, "presets": [{"name": "status_dominant", "reward_stats": {"min": 0.0, "max": 0.94988875, "mean": 0.8531436877962084, "median": 0.925871875, "std": 0.24481369618427912}, "status_counts": {"success": 195, "failure": 16, "other": 0}, "duration_stats": {"all": {"min": 136.0, "mean": 39257.38388625593, "p95": 48065.0, "max": 101799.0}, "success": {"min": 26726.0, "mean": 41582.88717948718, "p95": 48065.0, "max": 101799.0}, "failure": {"min": 136.0, "mean": 10915.3125, "p95": 97359.0, "max": 97359.0}}, "threshold_curves": [{"threshold": 0.05, "success_rate": 0.9241706161137441}, {"threshold": 0.1, "success_rate": 0.9241706161137441}, {"threshold": 0.15, "success_rate": 0.9241706161137441}, {"threshold": 0.2, "success_rate": 0.9241706161137441}, {"threshold": 0.25, "success_rate": 0.9241706161137441}, {"threshold": 0.3, "success_rate": 0.9241706161137441}, {"threshold": 0.35, "success_rate": 0.9241706161137441}, {"threshold": 0.4, "success_rate": 0.9241706161137441}, {"threshold": 0.45, "success_rate": 0.9241706161137441}, {"threshold": 0.5, "success_rate": 0.9241706161137441}, {"threshold": 0.55, "success_rate": 0.9241706161137441}, {"threshold": 0.6, "success_rate": 0.9241706161137441}, {"threshold": 0.65, "success_rate": 0.9241706161137441}, {"threshold": 0.7, "success_rate": 0.9241706161137441}, {"threshold": 0.75, "success_rate": 0.9241706161137441}, {"threshold": 0.8, "success_rate": 0.9241706161137441}, {"threshold": 0.85, "success_rate": 0.9241706161137441}, {"threshold": 0.9, "success_rate": 0.8909952606635071}, {"threshold": 0.95, "success_rate": 0.0}]}, {"name": "latency_sensitive", "reward_stats": {"min": 0.0, "max": 0.6483421052631579, "mean": 0.46628454726864554, "median": 0.5, "std": 0.13486841128017354}, "status_counts": {"success": 195, "failure": 16, "other": 0}, "duration_stats": {"all": {"min": 136.0, "mean": 39257.38388625593, "p95": 48065.0, "max": 101799.0}, "success": {"min": 26726.0, "mean": 41582.88717948718, "p95": 48065.0, "max": 101799.0}, "failure": {"min": 136.0, "mean": 10915.3125, "p95": 97359.0, "max": 97359.0}}, "threshold_curves": [{"threshold": 0.05, "success_rate": 0.9241706161137441}, {"threshold": 0.1, "success_rate": 0.9241706161137441}, {"threshold": 0.15, "success_rate": 0.9241706161137441}, {"threshold": 0.2, "success_rate": 0.9241706161137441}, {"threshold": 0.25, "success_rate": 0.9241706161137441}, {"threshold": 0.3, "success_rate": 0.9241706161137441}, {"threshold": 0.35, "success_rate": 0.9241706161137441}, {"threshold": 0.4, "success_rate": 0.9241706161137441}, {"threshold": 0.45, "success_rate": 0.9241706161137441}, {"threshold": 0.5, "success_rate": 0.9241706161137441}, {"threshold": 0.55, "success_rate": 0.018957345971563982}, {"threshold": 0.6, "success_rate": 0.018957345971563982}, {"threshold": 0.65, "success_rate": 0.0}, {"threshold": 0.7, "success_rate": 0.0}, {"threshold": 0.75, "success_rate": 0.0}, {"threshold": 0.8, "success_rate": 0.0}, {"threshold": 0.85, "success_rate": 0.0}, {"threshold": 0.9, "success_rate": 0.0}, {"threshold": 0.95, "success_rate": 0.0}]}, {"name": "balanced", "reward_stats": {"min": 0.0, "max": 0.7772833333333333, "mean": 0.6140246050552922, "median": 0.6705416666666666, "std": 0.18006693612513752}, "status_counts": {"success": 195, "failure": 16, "other": 0}, "duration_stats": {"all": {"min": 136.0, "mean": 39257.38388625593, "p95": 48065.0, "max": 101799.0}, "success": {"min": 26726.0, "mean": 41582.88717948718, "p95": 48065.0, "max": 101799.0}, "failure": {"min": 136.0, "mean": 10915.3125, "p95": 97359.0, "max": 97359.0}}, "threshold_curves": [{"threshold": 0.05, "success_rate": 0.9241706161137441}, {"threshold": 0.1, "success_rate": 0.9241706161137441}, {"threshold": 0.15, "success_rate": 0.9241706161137441}, {"threshold": 0.2, "success_rate": 0.9241706161137441}, {"threshold": 0.25, "success_rate": 0.9241706161137441}, {"threshold": 0.3, "success_rate": 0.9241706161137441}, {"threshold": 0.35, "success_rate": 0.9241706161137441}, {"threshold": 0.4, "success_rate": 0.9241706161137441}, {"threshold": 0.45, "success_rate": 0.9241706161137441}, {"threshold": 0.5, "success_rate": 0.9241706161137441}, {"threshold": 0.55, "success_rate": 0.8909952606635071}, {"threshold": 0.6, "success_rate": 0.8767772511848341}, {"threshold": 0.65, "success_rate": 0.7914691943127962}, {"threshold": 0.7, "success_rate": 0.018957345971563982}, {"threshold": 0.75, "success_rate": 0.018957345971563982}, {"threshold": 0.8, "success_rate": 0.0}, {"threshold": 0.85, "success_rate": 0.0}, {"threshold": 0.9, "success_rate": 0.0}, {"threshold": 0.95, "success_rate": 0.0}]}, {"name": "governance_conservative", "reward_stats": {"min": 0.0, "max": 0.73274, "mean": 0.5519954028436019, "median": 0.60465, "std": 0.16475601985910568}, "status_counts": {"success": 195, "failure": 16, "other": 0}, "duration_stats": {"all": {"min": 136.0, "mean": 39257.38388625593, "p95": 48065.0, "max": 101799.0}, "success": {"min": 26726.0, "mean": 41582.88717948718, "p95": 48065.0, "max": 101799.0}, "failure": {"min": 136.0, "mean": 10915.3125, "p95": 97359.0, "max": 97359.0}}, "threshold_curves": [{"threshold": 0.05, "success_rate": 0.9241706161137441}, {"threshold": 0.1, "success_rate": 0.9241706161137441}, {"threshold": 0.15, "success_rate": 0.9241706161137441}, {"threshold": 0.2, "success_rate": 0.9241706161137441}, {"threshold": 0.25, "success_rate": 0.9241706161137441}, {"threshold": 0.3, "success_rate": 0.9241706161137441}, {"threshold": 0.35, "success_rate": 0.9241706161137441}, {"threshold": 0.4, "success_rate": 0.9241706161137441}, {"threshold": 0.45, "success_rate": 0.8909952606635071}, {"threshold": 0.5, "success_rate": 0.8909952606635071}, {"threshold": 0.55, "success_rate": 0.8388625592417062}, {"threshold": 0.6, "success_rate": 0.5876777251184834}, {"threshold": 0.65, "success_rate": 0.018957345971563982}, {"threshold": 0.7, "success_rate": 0.018957345971563982}, {"threshold": 0.75, "success_rate": 0.0}, {"threshold": 0.8, "success_rate": 0.0}, {"threshold": 0.85, "success_rate": 0.0}, {"threshold": 0.9, "success_rate": 0.0}, {"threshold": 0.95, "success_rate": 0.0}]}]}};
    const ts = data.timestamps;
    const t1 = data.top1;
    const t3 = data.top3;
    const mae = data.cont_mae;
    const calibrationSeries = data.calibration_error || [];
    const latencyP50 = data.latency_p50 || [];
    const latencyP95 = data.latency_p95 || [];
    const latencyP99 = data.latency_p99 || [];
    const staging = data.thresholds.staging || {};
    const prod = data.thresholds.production || {};
    const ckpts = data.checkpoints || [];
    const ckptNames = data.checkpoint_names || [];
    const runNames = data.run_names || [];
    const extraMetricStats = data.extra_metric_stats || {};

    const custom = ts.map((_, idx) => [
      ckptNames[idx] || "",
      runNames[idx] || "",
      ckpts[idx] || "",
    ]);

    function makeTrace(x, y, name, yaxis) {
      return {
        x,
        y,
        mode: 'lines+markers',
        name,
        yaxis: yaxis || 'y',
        customdata: custom,
        hovertemplate:
          'ts=%{x}<br>' + name + '=%{y:.3f}<br>' +
          'checkpoint=%{customdata[0]}<br>' +
          'run=%{customdata[1]}' +
          '<extra></extra>',
      };
    }

    const traces = [];
    const thresholdToggleEntries = [];
    traces.push(makeTrace(ts, t1, 'top1_accuracy', 'y1'));
    traces.push(makeTrace(ts, t3, 'top3_accuracy', 'y1'));
    if (mae.some(v => v !== null)) {
      traces.push(makeTrace(ts, mae, 'cont_mae', 'y2'));
    }

    function addThresholdTrace(label, value, color, yaxis) {
      if (value == null || Number.isNaN(value)) {
        return;
      }
      const trace = {
        x: ts,
        y: ts.map(() => value),
        mode: 'lines',
        name: label,
        line: {dash: 'dash', color},
        yaxis,
      };
      const index = traces.push(trace) - 1;
      thresholdToggleEntries.push({label, index});
    }

    addThresholdTrace('staging min_top1', staging.min_top1_accuracy, 'orange', 'y1');
    addThresholdTrace('production min_top1', prod.min_top1_accuracy, 'red', 'y1');
    addThresholdTrace('staging max_cont_mae', staging.max_cont_mae, 'orange', 'y2');
    addThresholdTrace('production max_cont_mae', prod.max_cont_mae, 'red', 'y2');

    Plotly.newPlot('global-metrics', traces, {
      title: 'Global DT Metrics Over Time',
      xaxis: {title: 'timestamp'},
      yaxis: {title: 'accuracy'},
      yaxis2: {title: 'cont_mae', overlaying: 'y', side: 'right'},
      legend: {orientation: 'h'},
    });

    const circleTraces = [];
    for (const [circle, series] of Object.entries(data.per_circle)) {
      circleTraces.push(makeTrace(series.x, series.y, circle, 'y'));
    }
    Plotly.newPlot('per-circle', circleTraces, {
      title: 'Per-circle top1_accuracy Over Time',
      xaxis: {title: 'timestamp'},
      yaxis: {title: 'top1_accuracy'},
      legend: {orientation: 'h'},
    });

    function renderSummary() {
      const top1Stats = data.top1_stats || {};
      const top3Stats = data.top3_stats || {};
      const maeStats = data.cont_mae_stats || {};
      const extraStats = data.extra_metric_stats || {};

      function statsRow(name, stats) {
        if (!stats || Object.keys(stats).length === 0) return '';
        const vals = [
          stats.min, stats.p25, stats.median, stats.p75, stats.p90, stats.max,
        ].map(v => (v == null ? '' : v.toFixed(3)));
        return '<tr><td>' + name + '</td>' +
               '<td>' + vals[0] + '</td><td>' + vals[1] + '</td>' +
               '<td>' + vals[2] + '</td><td>' + vals[3] + '</td>' +
               '<td>' + vals[4] + '</td><td>' + vals[5] + '</td></tr>';
      }

      let html = '<table border="1" cellpadding="4" cellspacing="0">' +
        '<thead><tr><th>Metric</th><th>min</th><th>p25</th><th>median</th>' +
        '<th>p75</th><th>p90</th><th>max</th></tr></thead><tbody>';
      html += statsRow('top1_accuracy', top1Stats);
      html += statsRow('top3_accuracy', top3Stats);
      html += statsRow('cont_mae', maeStats);
      for (const [metric, stats] of Object.entries(extraStats)) {
        const label = metric.replace(/_/g, ' ');
        html += statsRow(label, stats);
      }
      html += '</tbody></table>';
      document.getElementById('summary-table').innerHTML = html;

      const impact = data.config_impact || {};
      let impactHtml = '<h3>Threshold impact (pass rates)</h3>';
      const cfgNames = Object.keys(impact);
      if (cfgNames.length === 0) {
        impactHtml += '<p>No threshold configurations available.</p>';
      } else {
        impactHtml += '<table border="1" cellpadding="4" cellspacing="0">' +
          '<thead><tr><th>Config</th><th>Pass%</th><th>Pass</th>' +
          '<th>Fail</th><th>Top failure reasons</th></tr></thead><tbody>';
        for (const cfg of cfgNames) {
          const c = impact[cfg];
          const reasons = Object.entries(c.failure_reasons || {})
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([name, count]) => name + ' (' + count + ')')
            .join(', ') || '-';
          const ratePct = (c.pass_rate * 100).toFixed(1);
          impactHtml += '<tr><td>' + cfg + '</td><td>' + ratePct + '</td>' +
            '<td>' + c.pass_count + '</td><td>' + c.fail_count + '</td>' +
            '<td>' + reasons + '</td></tr>';
        }
        impactHtml += '</tbody></table>';
      }
      document.getElementById('config-impact-table').innerHTML = impactHtml;

      const ckSummary = data.checkpoint_summary || {};
      let ckHtml = '<h3>Checkpoint comparison</h3>';
      const ckNames = Object.keys(ckSummary);
      if (ckNames.length === 0) {
        ckHtml += '<p>No checkpoints found.</p>';
      } else {
        ckHtml += '<table border="1" cellpadding="4" cellspacing="0">' +
          '<thead><tr><th>Checkpoint</th><th>Evaluations</th>' +
          '<th>median top1</th><th>median cont_mae</th></tr></thead><tbody>';
        for (const name of ckNames) {
          const s = ckSummary[name];
          const medTop1 = s.median_top1 != null ? s.median_top1.toFixed(3) : '';
          const medMae = s.median_cont_mae != null ? s.median_cont_mae.toFixed(3) : '-';
          ckHtml += '<tr><td>' + name + '</td><td>' + s.count + '</td>' +
            '<td>' + medTop1 + '</td><td>' + medMae + '</td></tr>';
        }
        ckHtml += '</tbody></table>';
      }
      document.getElementById('checkpoint-comparison').innerHTML = ckHtml;
    }


    function renderRewardPresets() {
      const container = document.getElementById('reward-presets-summary');
      if (!container) return;

      const rpa = data.reward_preset_analysis || null;
      if (!rpa || !Array.isArray(rpa.presets) || rpa.presets.length === 0) {
        container.innerHTML = '<p>No reward preset analysis available. Provide a trajectories file when generating the dashboard.</p>';
        const plotDiv = document.getElementById('reward-presets-plot');
        if (plotDiv) {
          plotDiv.innerHTML = '';
        }
        return;
      }

      const presets = rpa.presets;
      let html = '<table border="1" cellpadding="4" cellspacing="0">' +
        '<thead><tr><th>Preset</th><th>mean reward</th><th>median reward</th>' +
        '<th>success</th><th>failure</th><th>other</th></tr></thead><tbody>';
      for (const p of presets) {
        const rs = p.reward_stats || {};
        const sc = p.status_counts || {};
        const mean = rs.mean != null ? rs.mean.toFixed(3) : '';
        const median = rs.median != null ? rs.median.toFixed(3) : '';
        html += '<tr><td>' + p.name + '</td>' +
          '<td>' + mean + '</td><td>' + median + '</td>' +
          '<td>' + (sc.success || 0) + '</td>' +
          '<td>' + (sc.failure || 0) + '</td>' +
          '<td>' + (sc.other || 0) + '</td></tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;

      const traces = [];
      for (const p of presets) {
        const curve = p.threshold_curves || [];
        if (!curve.length) continue;
        const xs = curve.map(c => c.threshold);
        const ys = curve.map(c => c.success_rate);
        traces.push({
          x: xs,
          y: ys,
          mode: 'lines',
          name: p.name,
        });
      }
      const plotDiv = document.getElementById('reward-presets-plot');
      if (plotDiv && traces.length > 0) {
        Plotly.newPlot('reward-presets-plot', traces, {
          title: 'Reward threshold vs success rate',
          xaxis: {title: 'reward threshold'},
          yaxis: {title: 'fraction of steps with reward â‰¥ threshold', range: [0, 1]},
          legend: {orientation: 'h'},
        });
      } else if (plotDiv) {
        plotDiv.innerHTML = '';
      }
    }

    function renderThresholdToggles() {
      const container = document.getElementById('threshold-toggles');
      if (!container) return;
      if (thresholdToggleEntries.length === 0) {
        container.innerHTML = '<p>No threshold lines available.</p>';
        return;
      }
      const fragment = document.createDocumentFragment();
      thresholdToggleEntries.forEach((entry, idx) => {
        const wrapper = document.createElement('div');
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `threshold-toggle-${idx}`;
        checkbox.checked = true;
        checkbox.addEventListener('change', (event) => {
          const visible = event.target.checked ? true : 'legendonly';
          Plotly.restyle('global-metrics', {visible}, [entry.index]);
        });
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(' ' + entry.label));
        wrapper.appendChild(label);
        fragment.appendChild(wrapper);
      });
      container.innerHTML = '';
      container.appendChild(fragment);
    }

    function renderCalibrationMetrics() {
      const calibDiv = document.getElementById('calibration-ece');
      if (!calibDiv) return;
      if (!Array.isArray(calibrationSeries) || calibrationSeries.length === 0 || !calibrationSeries.some(v => v != null)) {
        calibDiv.innerHTML = '<p>No calibration metrics available.</p>';
        return;
      }
      const calibTrace = {
        x: ts,
        y: calibrationSeries,
        mode: 'lines+markers',
        name: 'calibration_error',
        line: {color: '#6c5ce7'},
        customdata: custom,
        hovertemplate:
          'ts=%{x}<br>calibration_error=%{y:.3f}<br>' +
          'checkpoint=%{customdata[0]}<br>' +
          'run=%{customdata[1]}' +
          '<extra></extra>',
      };
      const traces = [calibTrace];
      const stats = (extraMetricStats && extraMetricStats['calibration_error']) || null;
      function addBand(label, value, color, dash) {
        if (value == null || Number.isNaN(value)) return;
        traces.push({
          x: ts,
          y: ts.map(() => value),
          mode: 'lines',
          name: label,
          line: {color, dash},
          hoverinfo: 'skip',
        });
      }
      if (stats) {
        addBand('median', stats.median, '#636e72', 'dash');
        addBand('p25', stats.p25, '#b2bec3', 'dot');
        addBand('p75', stats.p75, '#b2bec3', 'dot');
      }
      Plotly.newPlot('calibration-ece', traces, {
        title: 'Calibration error over time',
        xaxis: {title: 'timestamp'},
        yaxis: {title: 'Expected Calibration Error (ECE)', range: [0, 1]},
        legend: {orientation: 'h'},
      });
    }

    function renderLatencyMetrics() {
      const latDiv = document.getElementById('latency-metrics');
      if (!latDiv) return;
      const latencySeries = [
        {name: 'latency_p50', values: latencyP50, color: '#4c78a8', dash: 'solid'},
        {name: 'latency_p95', values: latencyP95, color: '#f58518', dash: 'dash'},
        {name: 'latency_p99', values: latencyP99, color: '#e45756', dash: 'dot'},
      ];
      const latencyTraces = [];
      latencySeries.forEach(series => {
        if (!Array.isArray(series.values)) return;
        const hasData = series.values.some(v => v != null);
        if (!hasData) return;
        latencyTraces.push({
          x: ts,
          y: series.values,
          mode: 'lines+markers',
          name: series.name,
          line: {color: series.color, dash: series.dash},
          customdata: custom,
          hovertemplate:
            'ts=%{x}<br>' + series.name + '=%{y:.3f}<br>' +
            'checkpoint=%{customdata[0]}<br>' +
            'run=%{customdata[1]}' +
            '<extra></extra>',
        });
      });
      if (latencyTraces.length === 0) {
        latDiv.innerHTML = '<p>No latency metrics available.</p>';
        return;
      }
      Plotly.newPlot('latency-metrics', latencyTraces, {
        title: 'Latency percentiles over time',
        xaxis: {title: 'timestamp'},
        yaxis: {title: 'Inference Latency (seconds)'},
        legend: {orientation: 'h'},
      });
    }

    renderSummary();
    renderRewardPresets();
    renderThresholdToggles();
    renderCalibrationMetrics();
    renderLatencyMetrics();
  </script>
</body>
</html>
