#!/usr/bin/env bash
#
# af - Agentic Flow Unified Command Interface
#
# Consolidates tool contexts into single interface to reduce friction
# and close Build-Measure-Learn feedback loops.
#
# Usage: af <command> [args]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

# Pattern metrics logging helper
log_pattern_event() {
    local pattern="$1"
    local mode="$2"
    local gate="$3"
    local reason="$4"
    local action="$5"
    local context_json="${6:-}"

    # Validate known patterns to keep metrics clean
    case "$pattern" in
        depth-ladder|safe-degrade|circle-risk-focus|autocommit-shadow|guardrail-lock|failure-strategy|iteration-budget|observability-first)
            ;;
        *)
            # Unknown pattern; skip logging to avoid polluting metrics
            return 0
            ;;
    esac

    local ts
    ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

    local run_kind="${AF_RUN_KIND:-unknown}"
    local iteration="${AF_RUN_ITERATION:-0}"
    local circle="${AF_CIRCLE:-unknown}"
    local depth="${AF_DEPTH_LEVEL:-0}"
    local framework="${AF_FRAMEWORK:-}"
    local scheduler="${AF_SCHEDULER:-}"
    local mutation="false"
    if [[ "$mode" == *"mutate"* ]] || [[ "$mode" == *"enforce"* ]] || [[ "$mode" == *"blocking"* ]]; then
        mutation="true"
    fi

    # Ensure .goalie directory exists
    mkdir -p "$PROJECT_ROOT/.goalie"

    # Base JSON fields
    printf "{\"ts\":\"%s\",\"run\":\"%s\",\"iteration\":%s," \
        "$ts" "$run_kind" "$iteration" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"
    printf "\"circle\":\"%s\",\"depth\":%s," \
        "$circle" "$depth" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"
    printf "\"pattern\":\"%s\",\"mode\":\"%s\",\"mutation\":%s,\"gate\":\"%s\"," \
        "$pattern" "$mode" "$mutation" "$gate" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"

    # Final fields + optional context JSON (must be valid JSON value, typically an object)
    printf "\"framework\":\"%s\",\"scheduler\":\"%s\",\"reason\":\"%s\",\"action\":\"%s\"" \
        "$framework" "$scheduler" "$reason" "$action" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"

    if [ -n "$context_json" ]; then
        printf ",\"context\":%s" "$context_json" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"
    fi

    printf "}\n" >> "$PROJECT_ROOT/.goalie/pattern_metrics.jsonl"
}

show_help() {
    cat <<EOF
${BLUE}af - Agentic Flow Unified Command Interface${NC}

${GREEN}Status & Analysis:${NC}
  af status              Show comprehensive system status
  af metrics             Display metrics dashboard
  af analyze             Run doc_query analysis

${GREEN}Production Maturity & Observability:${NC}
  af retro-analysis      Run production maturity retrospective analysis
  af flow-metrics        Show flow & learning metrics (WSJF, BML throughput)
  af validate-success    Validate production success criteria
  af validate-dt         Validate Decision Transformer trajectories

${GREEN}Feedback Loop:${NC}
  af insight <text>      Capture retro insight
  af action <title>      Create tracked action item
  af quick-wins          Show Quick Wins progress
  af wsjf                Calculate WSJF priorities

${GREEN}Environment:${NC}
  af snapshot [name]     Create environment snapshot
  af restore [name]      Restore environment snapshot
  af baseline            Capture baseline metrics

${GREEN}Validation:${NC}
  af validate            Run governor validation
  af test                Run concurrent tests
  af governor            Check governor stats
  af governor-health     Validate governor + process tree + BML health

${GREEN}Learning:${NC}
  af hooks               Check hook discoverability
  af events              Show recent learning events
  af beam                Show BEAM dimensions

${GREEN}Build-Measure-Learn:${NC}
  af cycle               Show current BML cycle status
  af commit              Create BML cycle commit
  af feedback            Analyze feedback loops
  af action              Create retro action item
  af suggest-team        Suggest circle teams for NOW items (read-only)
  af suggest-actions     Suggest actions from recent insights (read-only)
  af full-cycle [n]      Run n full BML + health passes (default 1)

${GREEN}Context Reduction:${NC}
  af board               Show Kanban board (NOW/NEXT/LATER)
  af blockers            List active blockers
  af cpu                 Check CPU and governor health

Examples:
  af status                    # Quick health check
  af insight "Reduce CPU load" # Capture retro insight
  af action "Fix IPMI"         # Create tracked action
  af snapshot baseline         # Save current state
  af board                     # Show work in progress

EOF
}

# Status command - comprehensive health check
cmd_status() {
    echo -e "${BLUE}=== Agentic Flow Status ===${NC}\n"

    # Git status
    echo -e "${GREEN}Git:${NC}"
    git --no-pager log --oneline -1
    echo ""

    # AgentDB status
    echo -e "${GREEN}AgentDB:${NC}"
    if [ -f "$PROJECT_ROOT/.agentdb/agentdb.sqlite" ]; then
        echo "  Tables: $(sqlite3 "$PROJECT_ROOT/.agentdb/agentdb.sqlite" "SELECT COUNT(*) FROM sqlite_master WHERE type='table';")"
        echo "  execution_contexts: $(sqlite3 "$PROJECT_ROOT/.agentdb/agentdb.sqlite" "SELECT COUNT(*) FROM execution_contexts;" 2>/dev/null || echo "0")"
        echo "  beam_dimensions: $(sqlite3 "$PROJECT_ROOT/.agentdb/agentdb.sqlite" "SELECT COUNT(*) FROM beam_dimensions;" 2>/dev/null || echo "0")"
    else
        echo "  ❌ AgentDB not found"
    fi
    echo ""

    # Goalie status
    echo -e "${GREEN}Goalie Tracking:${NC}"
    if [ -f "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" ]; then
        local now_count=$(grep -A 20 "NOW:" "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" | grep -e "- id:" | wc -l | tr -d ' ')
        local next_count=$(grep -A 20 "NEXT:" "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" | grep -e "- id:" | wc -l | tr -d ' ')
        local done_count=$(grep -A 100 "DONE:" "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" | grep -e "- id:" | wc -l | tr -d ' ')
        echo "  NOW: $now_count | NEXT: $next_count | DONE: $done_count"
    fi
    echo ""

    # CPU & Governor
    echo -e "${GREEN}System Health:${NC}"
    local load=$(uptime | awk -F'load averages:' '{print $2}' | awk '{print $1}')
    echo "  Load: $load"
    if [ -f "$PROJECT_ROOT/logs/governor_incidents.jsonl" ]; then
        local incidents=$(wc -l < "$PROJECT_ROOT/logs/governor_incidents.jsonl" | tr -d ' ')
        echo "  Governor incidents: $incidents"
    fi
    echo ""

    # Snapshots
    echo -e "${GREEN}Snapshots:${NC}"
    if [ -d "$PROJECT_ROOT/.snapshots" ]; then
        ls -1 "$PROJECT_ROOT/.snapshots" | head -5
    else
        echo "  (no snapshots)"
    fi
}

# Metrics dashboard
cmd_metrics() {
    if [ -f "$PROJECT_ROOT/.goalie/metrics_dashboard.md" ]; then
        cat "$PROJECT_ROOT/.goalie/metrics_dashboard.md"
    else
        echo -e "${YELLOW}Metrics dashboard not found. Run: $SCRIPT_DIR/baseline-metrics.sh${NC}"
    fi
}

# Doc query analysis
cmd_analyze() {
    local query="${1:-BLOCKER|retro|Quick Win}"
    python3 "$SCRIPT_DIR/doc_query.py" "$query"
}

# Capture insight
cmd_insight() {
    local text="$*"
    if [ -z "$text" ]; then
        echo "Usage: af insight <text>"
        exit 1
    fi

    local timestamp=$(date -u +%Y%m%d_%H%M%S)
    echo "{\"timestamp\": \"$timestamp\", \"type\": \"retro_insight\", \"text\": \"$text\"}" | \
        tee -a "$PROJECT_ROOT/.goalie/insights_log.jsonl"
    echo -e "${GREEN}✓ Insight captured${NC}"
}

# Create action item
cmd_action() {
    local title="$*"
    if [ -z "$title" ]; then
        echo "Usage: af action <title>"
        exit 1
    fi

    if [ -f "$SCRIPT_DIR/create_action_item.sh" ]; then
        bash "$SCRIPT_DIR/create_action_item.sh" "$title"
    else
        echo -e "${YELLOW}create_action_item.sh not found${NC}"
        # Fallback: append to CONSOLIDATED_ACTIONS.yaml
        echo "  - title: \"$title\"" >> "$PROJECT_ROOT/.goalie/CONSOLIDATED_ACTIONS.yaml"
        echo -e "${GREEN}✓ Action added to CONSOLIDATED_ACTIONS.yaml${NC}"
    fi
}

# Suggest circle teams for NOW items (read-only)
cmd_suggest_team() {
    echo -e "${BLUE}=== Suggested Circle Teams (NOW lane) ===${NC}\n"
    if [ -f "$SCRIPT_DIR/agentic/suggest_team.py" ]; then
        python3 "$SCRIPT_DIR/agentic/suggest_team.py" || \
            echo -e "${YELLOW}suggest_team.py failed${NC}"
    else
        echo -e "${YELLOW}suggest_team.py not found${NC}"
    fi
}

# Suggest actions from recent insights (read-only)
cmd_suggest_actions() {
    echo -e "${BLUE}=== Suggested Actions from Recent Insights ===${NC}\n"
    if [ -f "$SCRIPT_DIR/agentic/suggest_actions.py" ]; then
        python3 "$SCRIPT_DIR/agentic/suggest_actions.py" || \
            echo -e "${YELLOW}suggest_actions.py failed${NC}"
    else
        echo -e "${YELLOW}suggest_actions.py not found${NC}"
    fi
}

# Quick wins progress
cmd_quick_wins() {
    if [ -f "$SCRIPT_DIR/show_quick_wins_progress.sh" ]; then
        bash "$SCRIPT_DIR/show_quick_wins_progress.sh"
    else
        echo -e "${YELLOW}show_quick_wins_progress.sh not found${NC}"
        if [ -f "$PROJECT_ROOT/docs/QUICK_WINS.md" ]; then
            grep -E "^\- \[.\]" "$PROJECT_ROOT/docs/QUICK_WINS.md" | head -20
        fi
    fi
}

# WSJF calculation
cmd_wsjf() {
    if command -v npx &> /dev/null; then
        cd "$PROJECT_ROOT" && npx goalie@latest recalc-wsjf 2>&1 || echo -e "${YELLOW}goalie not available${NC}"
    else
        echo -e "${YELLOW}npx not found${NC}"
    fi
}

# Environment snapshot
cmd_snapshot() {
    local name="${1:-baseline}"
    bash "$SCRIPT_DIR/restore-environment.sh" --snapshot "$name"
}

# Environment restore
cmd_restore() {
    local name="${1:-baseline}"
    bash "$SCRIPT_DIR/restore-environment.sh" --snapshot "$name"
}

# Baseline metrics
cmd_baseline() {
    bash "$SCRIPT_DIR/baseline-metrics.sh" "$@"
}

# Governor validation
cmd_validate() {
    bash "$SCRIPT_DIR/validate-governor-integration.sh" "$@"
}

# Run tests
cmd_test() {
    if [ -f "$SCRIPT_DIR/run-concurrent-tests.sh" ]; then
        bash "$SCRIPT_DIR/run-concurrent-tests.sh"
    else
        cd "$PROJECT_ROOT" && npm test
    fi
}

# Governor stats
cmd_governor() {
    echo -e "${BLUE}=== Governor Stats ===${NC}\n"
    if [ -f "$PROJECT_ROOT/logs/governor_incidents.jsonl" ]; then
        local total=$(wc -l < "$PROJECT_ROOT/logs/governor_incidents.jsonl" | tr -d ' ')
        local recent=$(tail -10 "$PROJECT_ROOT/logs/governor_incidents.jsonl")
        echo "Total incidents: $total"
        echo ""
        echo "Recent (last 10):"
        echo "$recent" | jq -r '"\(.timestamp) - \(.reason)"' 2>/dev/null || echo "$recent"
    else
        echo "No incidents logged"
    fi
}

# Check hooks
cmd_hooks() {
    echo -e "${BLUE}=== Hook Discoverability ===${NC}\n"
    if [ -d "$PROJECT_ROOT/.agentdb/hooks" ]; then
        find "$PROJECT_ROOT/.agentdb/hooks" -type f
    else
        echo -e "${YELLOW}.agentdb/hooks not found${NC}"
    fi
}

# Learning events
cmd_events() {
    local count="${1:-20}"
    echo -e "${BLUE}=== Recent Learning Events ===${NC}\n"
    if [ -f "$PROJECT_ROOT/logs/learning/events.jsonl" ]; then
        tail -n "$count" "$PROJECT_ROOT/logs/learning/events.jsonl" | jq -r '"\(.timestamp) - \(.event)"' 2>/dev/null
    else
        echo -e "${YELLOW}logs/learning/events.jsonl not found${NC}"
    fi
}

# BEAM dimensions
cmd_beam() {
    echo -e "${BLUE}=== BEAM Dimensions ===${NC}\n"
    if [ -f "$PROJECT_ROOT/.agentdb/agentdb.sqlite" ]; then
        sqlite3 "$PROJECT_ROOT/.agentdb/agentdb.sqlite" \
            "SELECT * FROM beam_dimensions LIMIT 10;" 2>/dev/null || \
            echo "No BEAM dimensions found"
    else
        echo -e "${YELLOW}AgentDB not found${NC}"
    fi
}

# BML cycle status
cmd_cycle() {
    echo -e "${BLUE}=== Build-Measure-Learn Cycle ===${NC}\n"
    if [ -f "$PROJECT_ROOT/.goalie/cycle_log.jsonl" ]; then
        tail -5 "$PROJECT_ROOT/.goalie/cycle_log.jsonl" | jq -r 'select(.type == "BML-CYCLE") | "\(.id) - \(.status)"' 2>/dev/null
    else
        echo "No cycle log found"
    fi
}

# BML commit
cmd_commit() {
    local msg="${*:-BML cycle $(date +%Y%m%d_%H%M%S)}"
    cd "$PROJECT_ROOT"
    git add .goalie/ .agentdb/ logs/ metrics/ 2>/dev/null || true
    git commit -m "$msg" || echo -e "${YELLOW}Nothing to commit${NC}"
}

# Feedback analysis
cmd_feedback() {
    if [ -f "$SCRIPT_DIR/feedback-loop-analyzer.sh" ]; then
        bash "$SCRIPT_DIR/feedback-loop-analyzer.sh"
    else
        echo -e "${YELLOW}feedback-loop-analyzer.sh not found${NC}"
    fi
}

# Full BML + health cycle
cmd_full_cycle() {
    local iterations="${1:-1}"

    case "$iterations" in
        ''|*[!0-9]*)
            echo -e "${YELLOW}Invalid iteration count: $iterations (must be positive integer)${NC}"
            return 1
            ;;
    esac

    if [ "$iterations" -le 0 ]; then
        echo -e "${YELLOW}Iteration count must be > 0${NC}"
        return 1
    fi

    local i
    for i in $(seq 1 "$iterations"); do
        echo -e "${BLUE}=== Full BML + Health Cycle $i/$iterations ===${NC}\n"

        cmd_status
        echo ""
        cmd_board
        echo ""
        cmd_suggest_team
        echo ""
        cmd_metrics
        echo ""
        cmd_cycle
        echo ""
        cmd_governor_health
        echo ""

        if [ -f "$SCRIPT_DIR/doc_query.py" ]; then
            echo -e "${BLUE}=== Circle Roles Snapshot (doc_query) ===${NC}\n"
            python3 "$SCRIPT_DIR/doc_query.py" "Analyst|Assessor|Innovator|Intuitive|Seeker" --max-depth 6 || \
                echo -e "${YELLOW}doc_query.py failed${NC}"
        fi

        cmd_suggest_actions
        echo ""

        # Optional autocommit path behind test-first guardrails
        local do_autocommit="${AF_FULL_CYCLE_AUTOCOMMIT:-0}"
        if [ "$do_autocommit" = "1" ]; then
            echo -e "${BLUE}=== Autocommit Guardrails (iteration $i) ===${NC}\n"

            # Test-first guardrail (can be disabled with AF_FULL_CYCLE_TEST_FIRST=0)
            local run_tests="${AF_FULL_CYCLE_TEST_FIRST:-1}"
            if [ "$run_tests" = "1" ]; then
                echo -e "${BLUE}Running tests via af test...${NC}\n"
                cmd_test
                local test_status=$?
                if [ "$test_status" -ne 0 ]; then
                    echo -e "${RED}Tests failed (status=$test_status); skipping autocommit for this iteration.${NC}"
                    METRIC_SAFE_DEGRADE_TRIGGERS=$((METRIC_SAFE_DEGRADE_TRIGGERS + 1))
                    continue
                fi

                echo -e "${BLUE}Running governor validation via af validate...${NC}\n"
                cmd_validate
                local validate_status=$?
                if [ "$validate_status" -ne 0 ]; then
                    echo -e "${RED}Governor validation failed (status=$validate_status); skipping autocommit for this iteration.${NC}"
                    METRIC_SAFE_DEGRADE_TRIGGERS=$((METRIC_SAFE_DEGRADE_TRIGGERS + 1))
                    continue
                fi
            fi

            # Only autocommit if there are changes, and warn if there are unsafe ones
            cd "$PROJECT_ROOT"
            local changed
            changed=$(git status --porcelain 2>/dev/null || true)
            METRIC_AUTOCOMMIT_CANDIDATES=$(echo "$changed" | grep -v "^$" | wc -l | tr -d ' ')
            if [ -z "$changed" ]; then
                echo -e "${YELLOW}No changes detected; nothing to autocommit.${NC}"
            else
                local unsafe
                unsafe=$(echo "$changed" | awk '{print $2}' | grep -Ev '^(\.goalie/|\.agentdb/|logs/|metrics/)' || true)

                if [ -n "$unsafe" ]; then
                    echo -e "${YELLOW}Unsafe changes detected outside [.goalie, .agentdb, logs, metrics]; autocommit will include only safe paths via cmd_commit.${NC}"
                    echo "$unsafe" | sed 's/^/  - /'
                fi

                echo -e "${GREEN}Creating BML full-cycle auto-commit for safe paths (.goalie, .agentdb, logs, metrics).${NC}"
                cmd_commit "BML full-cycle auto-commit (iteration $i of $iterations)"

                # Optional code-level autocommit under additional guardrails and policy
                local allow_code="${AF_ALLOW_CODE_AUTOCOMMIT:-0}"
                if [ "$allow_code" = "1" ] && [ -f "$PROJECT_ROOT/.goalie/autocommit_policy.yaml" ]; then
                    echo -e "${BLUE}Evaluating code-level autocommit via code_guardrails...${NC}\n"

                    local changed_paths
                    changed_paths=$(echo "$changed" | awk '{print $2}')

                    local safe_code_files
                    safe_code_files=$(printf '%s\n' "$changed_paths" | \
                        python3 "$SCRIPT_DIR/agentic/code_guardrails.py" --filter-code 2>/dev/null || true)

                    if [ -n "$safe_code_files" ]; then
                        echo -e "${GREEN}Staging code files approved by guardrails:${NC}"
                        echo "$safe_code_files" | sed 's/^/  - /'

                        while IFS= read -r f; do
                            [ -n "$f" ] && git add "$f"
                        done <<< "$safe_code_files"

                        git commit -m "BML full-cycle code auto-commit (iteration $i of $iterations)" || \
                            echo -e "${YELLOW}No code changes to commit (code-level).${NC}"
                    else
                        echo -e "${YELLOW}No eligible code files for auto-commit after guardrails.${NC}"
                    fi
                fi
            fi
        fi

        if [ "$i" -lt "$iterations" ]; then
            echo -e "\n${GREEN}--- End of iteration $i ---${NC}\n"
        fi
    done
}

# Kanban board
cmd_board() {
    if [ -f "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" ]; then
        cat "$PROJECT_ROOT/.goalie/KANBAN_BOARD.yaml" | grep -A 50 "NOW:" | head -60
    else
        echo -e "${YELLOW}KANBAN_BOARD.yaml not found${NC}"
    fi
}

# Active blockers
cmd_blockers() {
    python3 "$SCRIPT_DIR/doc_query.py" "BLOCKER-[0-9]+" | head -50
}

# CPU check
cmd_cpu() {
    echo -e "${BLUE}=== CPU & Governor Health ===${NC}\n"
    uptime
    echo ""
    if [ -f "$PROJECT_ROOT/logs/governor_incidents.jsonl" ]; then
        echo "Governor incidents (last 24h): $(find "$PROJECT_ROOT/logs/governor_incidents.jsonl" -mtime -1 -exec wc -l {} \; 2>/dev/null || echo "0")"
    fi
}

# Governor validation + health suite
cmd_governor_health() {
    echo -e "${BLUE}=== Governor Validation & Health Suite ===${NC}\n"

    # 1) Run governor validation
    if [ -f "$SCRIPT_DIR/validate-governor-integration.sh" ]; then
        bash "$SCRIPT_DIR/validate-governor-integration.sh" "$@"
    else
        echo -e "${YELLOW}validate-governor-integration.sh not found${NC}"
    fi

    echo ""

    # 2) Capture a single process tree snapshot
    if [ -f "$SCRIPT_DIR/monitoring/process_tree_watch.js" ]; then
        echo -e "${GREEN}Process tree snapshot (process_tree_watch --once):${NC}"
        node "$SCRIPT_DIR/monitoring/process_tree_watch.js" --once || \
            echo -e "${YELLOW}process_tree_watch.js failed${NC}"
    fi

    echo ""

    # 3) Run BML health check
    if [ -f "$SCRIPT_DIR/agentic/health_check.py" ]; then
        echo -e "${GREEN}BML health check:${NC}"
        python3 "$SCRIPT_DIR/agentic/health_check.py" || \
            echo -e "${YELLOW}health_check.py failed${NC}"
    else
        echo -e "${YELLOW}health_check.py not found${NC}"
    fi
}

cmd_multi_pattern_coverage() {
    local json_mode=0
    local dirs_arg=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_mode=1
                shift
                ;;
            --dirs)
                dirs_arg="${2:-}"
                shift 2
                ;;
            *)
                echo -e "${YELLOW}Ignoring unknown multi-pattern-coverage option: $1${NC}" >&2
                shift
                ;;
        esac
    done

    if [ "$json_mode" -ne 1 ]; then
        echo -e "${RED}multi-pattern-coverage currently supports only --json mode${NC}" >&2
        return 1
    fi

    if [ -z "$dirs_arg" ]; then
        # Default to current PROJECT_ROOT/.goalie for compatibility
        dirs_arg="${PROJECT_ROOT}/.goalie"
    fi

    IFS=',' read -r -a goalie_dirs <<< "$dirs_arg"

    AF_MULTI_GOALIE_DIRS="$dirs_arg" python3 - << 'PY'
import json
import os
import subprocess
import sys
from datetime import datetime

project_root = os.environ.get("PROJECT_ROOT", os.getcwd())

raw_dirs = os.environ.get("AF_MULTI_GOALIE_DIRS", "")
if not raw_dirs:
    print(json.dumps({"error": "AF_MULTI_GOALIE_DIRS not set"}))
    sys.exit(1)

goalie_dirs = [d.strip() for d in raw_dirs.split(',') if d.strip()]

if not goalie_dirs:
    print(json.dumps({"error": "No Goalie dirs provided"}))
    sys.exit(1)

per_env = []
all_patterns = {}

def run_pattern_coverage(goalie_dir: str):
    env = os.environ.copy()
    env["PROJECT_ROOT"] = project_root
    # Allow overriding Goalie dir via env for the called script
    env["AF_GOALIE_DIR"] = goalie_dir
    cmd = [os.path.join(project_root, "scripts", "af"), "pattern-coverage", "--json"]
    try:
        out = subprocess.check_output(cmd, env=env, stderr=subprocess.DEVNULL)
    except Exception as e:
        return {"error": f"failed to run pattern-coverage for {goalie_dir}: {e}"}
    try:
        return json.loads(out.decode("utf-8"))
    except Exception as e:
        return {"error": f"invalid JSON from pattern-coverage for {goalie_dir}: {e}"}

for gd in goalie_dirs:
    name = os.path.basename(os.path.normpath(gd)) or gd
    pc_json = run_pattern_coverage(gd)
    if "error" in pc_json:
        per_env.append({"name": name, "error": pc_json["error"]})
        continue

    per_env.append({
        "name": name,
        "coverage": pc_json.get("coverage", {}),
        "totals": pc_json.get("totals", {}),
        "patterns": pc_json.get("patterns", []),
    })

    for entry in pc_json.get("patterns", []):
        pname = entry.get("name")
        if not pname:
            continue
        agg = all_patterns.setdefault(pname, {"direct_events": 0, "inferred_events": 0})
        agg["direct_events"] += int(entry.get("direct_events", 0))
        agg["inferred_events"] += int(entry.get("inferred_events", 0))

# Compute global coverage across all envs
pattern_names = sorted(all_patterns.keys())
logged_patterns = 0
for pname in pattern_names:
    entry = all_patterns[pname]
    if entry["direct_events"] + entry["inferred_events"] > 0:
        logged_patterns += 1

total_patterns = len(pattern_names) or 8
coverage_pct = 0.0
if total_patterns > 0:
    coverage_pct = (float(logged_patterns) / float(total_patterns)) * 100.0

global_totals = {
    "direct_events": sum(v["direct_events"] for v in all_patterns.values()),
    "inferred_events": sum(v["inferred_events"] for v in all_patterns.values()),
}

payload = {
    "timestamp": datetime.utcnow().replace(microsecond=0).isoformat() + "Z",
    "environments": per_env,
    "global": {
        "coverage": {
            "unique_patterns_logged": logged_patterns,
            "total_patterns": total_patterns,
            "coverage_percentage": coverage_pct,
        },
        "totals": global_totals,
    },
}

print(json.dumps(payload))
PY
}


cmd_detect_observability_gaps() {
    echo -e "${BLUE}=== Observability Gap Detection ===${NC}\n"

    if [ -f "$SCRIPT_DIR/agentic/detect_observability_gaps.py" ]; then
        python3 "$SCRIPT_DIR/agentic/detect_observability_gaps.py" "$@"
    else
        echo -e "${RED}detect_observability_gaps.py not found at $SCRIPT_DIR/agentic/detect_observability_gaps.py${NC}"
        return 1
    fi
}

# Goalie Gaps Check (VSIX Validator)
cmd_goalie_gaps() {
    local vsix_path="${1:-}"
    if [ -z "$vsix_path" ]; then
        echo -e "${RED}Error: VSIX path required.${NC}"
        echo "Usage: af goalie-gaps <path-to-vsix>"
        return 1
    fi

    if [ ! -f "$vsix_path" ]; then
        echo -e "${RED}Error: VSIX file not found at $vsix_path${NC}"
        return 1
    fi

    echo -e "${BLUE}Validating VSIX: $vsix_path${NC}"

    local tmp_dir
    tmp_dir="$(mktemp -d)"
    trap 'rm -rf "$tmp_dir"' RETURN

    unzip -q "$vsix_path" -d "$tmp_dir"

    local ext_dir="$tmp_dir/extension"
    if [ ! -d "$ext_dir" ]; then
        echo -e "${RED}Error: Invalid VSIX structure (no extension/ folder)${NC}"
        return 1
    fi

    if [ ! -f "$ext_dir/scripts/gap-check.js" ]; then
        echo -e "${RED}Error: scripts/gap-check.js not found in VSIX${NC}"
        return 1
    fi

    echo "Running gap-check.js..."
    (cd "$ext_dir" && node scripts/gap-check.js)
}

# Governance federation helpers (Retro Coach + Governance Agent)
cmd_retro_coach() {
    cd "$PROJECT_ROOT"
    if command -v npx &> /dev/null; then
        npx tsx tools/federation/retro_coach.ts --goalie-dir "$PROJECT_ROOT/.goalie" "$@"
    else
        echo -e "${YELLOW}npx not found; cannot run retro_coach.ts${NC}"
        return 1
    fi
}

cmd_governance_agent() {
    cd "$PROJECT_ROOT"
    if command -v npx &> /dev/null; then
        npx tsx tools/federation/governance_agent.ts --goalie-dir "$PROJECT_ROOT/.goalie" "$@"
    else
        echo -e "${YELLOW}npx not found; cannot run governance_agent.ts${NC}"
        return 1
    fi
}

cmd_governance_executor() {
    cd "$PROJECT_ROOT"
    if ! command -v npx &> /dev/null; then
        echo -e "${YELLOW}npx not found; cannot run governance_executor.ts${NC}"
        return 1
    fi

    mkdir -p "$PROJECT_ROOT/.goalie"

    local tmp_json
    tmp_json="$(mktemp "$PROJECT_ROOT/.goalie/governance_payload_XXXXXX.json")"

    if ! cmd_governance_agent --json > "$tmp_json"; then
        echo -e "${YELLOW}governance_agent failed; skipping governance executor${NC}"
        rm -f "$tmp_json"
        return 0
    fi

    local summary_out="$PROJECT_ROOT/.goalie/executor_summary.json"
    local error_log="$PROJECT_ROOT/.goalie/executor_errors.log"

    if [ "${AF_GOVERNANCE_EXECUTOR_DRY_RUN:-1}" = "1" ]; then
        npx tsx tools/federation/governance_executor.ts --dry-run < "$tmp_json" \
            > "$summary_out" 2>> "$error_log" || true
    else
        npx tsx tools/federation/governance_executor.ts < "$tmp_json" \
            > "$summary_out" 2>> "$error_log" || true
    fi

    rm -f "$tmp_json"
}




# Production maturity cycle (Delegated to Governance Middleware)
cmd_prod_cycle() {
    local middleware_script="$SCRIPT_DIR/policy/governance.py"

    if [ ! -f "$middleware_script" ]; then
        echo -e "${RED}Error: Governance middleware not found at $middleware_script${NC}"
        exit 1
    fi

    # Invoke Python Middleware
    # Arguments are passed directly, allowing governance.py to parse flags
    python3 "$middleware_script" "$@"
}

# Dynamic Policy Hook
if [ -f "$SCRIPT_DIR/policy/dynamic_autocommit.sh" ] && [ "$1" == "prod-cycle" ]; then
    source "$SCRIPT_DIR/policy/dynamic_autocommit.sh"
fi


log_prod_cycle_iteration_metrics() {
    local run_kind="${AF_RUN_KIND:-unknown}"
    if [ "$run_kind" != "prod-cycle" ]; then
        return 0
    fi

    local ts
    ts="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"

    local iteration="${AF_RUN_ITERATION:-0}"
    local circle="${AF_CIRCLE:-unknown}"
    local depth="${AF_DEPTH_LEVEL:-0}"
    local mode="${AF_PROD_CYCLE_MODE:-advisory}"
    local run_id="${AF_RUN_ID:-unknown}"

    local requested="${AF_PC_REQUESTED_ITERATIONS:-0}"
    local max_iter="${AF_PC_MAX_ITER:-0}"
    local extensions="${AF_PC_EXTENSIONS_USED:-0}"
    local safe_degrade_triggers="${AF_PC_SAFE_DEGRADE_TRIGGERS:-0}"
    local recent_incidents="${AF_PC_RECENT_LOAD_INCIDENTS:-0}"
    local risk_score="${AF_PC_CURRENT_RISK_SCORE:-0}"

    local allow_code="${AF_ALLOW_CODE_AUTOCOMMIT:-0}"
    local full_autocommit="${AF_FULL_CYCLE_AUTOCOMMIT:-0}"
    local test_first="${AF_FULL_CYCLE_TEST_FIRST:-1}"
    local autocommit_runs="${AF_PC_AUTOCOMMIT_RUNS:-0}"

    local safe_degrade_reason="${AF_PC_SAFE_DEGRADE_REASON:-none}"

    local patt_depth_ladder="${AF_PROD_DEPTH_LADDER:-0}"
    local patt_safe_degrade="${AF_PROD_SAFE_DEGRADE:-0}"
    local patt_circle_risk_focus="${AF_PROD_CIRCLE_RISK_FOCUS:-0}"
    local patt_autocommit_shadow="${AF_PROD_AUTOCOMMIT_SHADOW:-0}"
    local patt_guardrail_lock="${AF_PROD_GUARDRAIL_LOCK:-0}"
    local patt_failure_strategy="${AF_PROD_FAILURE_STRATEGY:-0}"
    local patt_iteration_budget="${AF_PROD_ITERATION_BUDGET:-0}"
    local patt_observability_first="${AF_PROD_OBSERVABILITY_FIRST:-0}"

    local safe_degrade_actions="${AF_PC_SAFE_DEGRADE_ACTIONS:-[]}"
    local safe_degrade_recovery_raw="${AF_PC_SAFE_DEGRADE_RECOVERY_CYCLES:-0}"
    local safe_degrade_recovery="$safe_degrade_recovery_raw"
    if [[ "$safe_degrade_recovery_raw" =~ ^\[ ]]; then
      safe_degrade_recovery="0"
    fi

    local circle_risk_owner="${AF_PC_CIRCLE_RISK_FOCUS_TOP_OWNER:-none}"
    local circle_risk_extra="${AF_PC_CIRCLE_RISK_FOCUS_EXTRA_ITERATIONS:-0}"
    local circle_risk_reduction="${AF_PC_CIRCLE_RISK_FOCUS_ROAM_REDUCTION:-0}"

    local shadow_override="${AF_PC_AUTOCOMMIT_SHADOW_MANUAL_OVERRIDE:-0}"

    local guardrail_enforced="${AF_PC_GUARDRAIL_LOCK_ENFORCED:-0}"
    local guardrail_health="${AF_PC_GUARDRAIL_LOCK_HEALTH_STATE:-unknown}"
    local guardrail_requests="${AF_PC_GUARDRAIL_LOCK_USER_REQUESTS:-0}"

    local fail_strat_mode="${AF_PC_FAILURE_STRATEGY_MODE:-none}"
    local fail_strat_abort="${AF_PC_FAILURE_STRATEGY_ABORT_AT:-0}"
    local fail_strat_reason="${AF_PC_FAILURE_STRATEGY_DEGRADE_REASON:-none}"

    local budget_enforced="${AF_PC_ITERATION_BUDGET_ENFORCED:-0}"

    local obs_written="${AF_PC_OBSERVABILITY_METRICS_WRITTEN:-0}"
    local obs_missing="${AF_PC_OBSERVABILITY_MISSING_SIGNALS:-0}"
    local obs_suggest="${AF_PC_OBSERVABILITY_SUGGESTION_MADE:-0}"

    mkdir -p "$PROJECT_ROOT/.goalie"
    local out="$PROJECT_ROOT/.goalie/metrics_log.jsonl"

    # Use emit_metrics.py for strictly typed, schema-compliant logging
    # Calculates budget metrics: remaining = max - current, consumed = current
    local budget_remaining=$((max_iter - iteration))
    if [ "$budget_remaining" -lt 0 ]; then budget_remaining=0; fi

    python3 "$SCRIPT_DIR/emit_metrics.py" \
        --event-type "state" \
        --run-id "$run_id" \
        --cycle-index "$iteration" \
        --circle "$circle" \
        --depth "$depth" \
        --safe-degrade-triggers "$safe_degrade_triggers" \
        --safe-degrade-actions "$safe_degrade_actions" \
        --safe-degrade-recovery-cycles "$safe_degrade_recovery" \
        --circle-risk-focus-top-owner "$circle_risk_owner" \
        --circle-risk-focus-extra-iterations "$circle_risk_extra" \
        --circle-risk-focus-roam-reduction "$circle_risk_reduction" \
        --autocommit-shadow-manual-override "$shadow_override" \
        --guardrail-lock-enforced "$guardrail_enforced" \
        --guardrail-lock-health-state "$guardrail_health" \
        --guardrail-lock-user-requests "$guardrail_requests" \
        --failure-strategy-mode "$fail_strat_mode" \
        --failure-strategy-abort-iteration-at "$fail_strat_abort" \
        --failure-strategy-degrade-reason "$fail_strat_reason" \
        --iteration-budget-requested "$requested" \
        --iteration-budget-enforced "$budget_enforced" \
        --iteration-budget-autocommit-runs "$autocommit_runs" \
        --observability-first-metrics-written "$obs_written" \
        --observability-first-missing-signals "$obs_missing" \
        --observability-first-suggestion-made "$obs_suggest" \
        --autocommit-cycles "$autocommit_runs" \
        --budget-remaining "$budget_remaining" \
        --budget-consumed "$iteration" \
        --risk-score "$risk_score" \
        --recent-incidents "$recent_incidents" \
        --average-score "$risk_score" \
        --risk-distribution "${AF_PC_RISK_DISTRIBUTION:-{}}" \
        --log-file "$out" || echo "${YELLOW}Warning: Failed to emit metrics via emit_metrics.py${NC}"
}

# Main dispatch
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    case "${1:-help}" in
        status) cmd_status ;;
        metrics) cmd_metrics ;;
        analyze) shift; cmd_analyze "$@" ;;
        insight) shift; cmd_insight "$@" ;;
        action) shift; cmd_action "$@" ;;
        suggest-team) shift; cmd_suggest_team "$@" ;;
        suggest-actions) shift; cmd_suggest_actions "$@" ;;
        quick-wins) cmd_quick_wins ;;
        wsjf) cmd_wsjf ;;
        snapshot) shift; cmd_snapshot "$@" ;;
        restore) shift; cmd_restore "$@" ;;
        baseline) shift; cmd_baseline "$@" ;;
        validate) shift; cmd_validate "$@" ;;
        test) cmd_test ;;
        governor) cmd_governor ;;
        governor-health) shift; cmd_governor_health "$@" ;;
        hooks) cmd_hooks ;;
        events) shift; cmd_events "$@" ;;
        beam) cmd_beam ;;
        full-cycle) shift; cmd_full_cycle "${1:-1}" ;;
        prod-cycle) shift; cmd_prod_cycle "$@" ;;
        cycle) cmd_cycle ;;
        commit) shift; cmd_commit "$@" ;;
        feedback) cmd_feedback ;;
        board) cmd_board ;;
        blockers) cmd_blockers ;;
        cpu) cmd_cpu ;;
        goalie-gaps) shift; cmd_goalie_gaps "$@" ;;
        pattern-coverage) shift; cmd_pattern_coverage "$@" ;;
        multi-pattern-coverage) shift; cmd_multi_pattern_coverage "$@" ;;
        detect-observability-gaps) shift; cmd_detect_observability_gaps "$@" ;;
        sample-workloads) shift; cmd_sample_workloads "$@" ;;
        retro-coach) shift; cmd_retro_coach "$@" ;;
        governance-agent) shift; cmd_governance_agent "$@" ;;
        retro-analysis)
            shift
            if [ -x "$SCRIPT_DIR/analysis/retrospective_analysis.py" ]; then
                python3 "$SCRIPT_DIR/analysis/retrospective_analysis.py" "$@"
            else
                echo -e "${YELLOW}retrospective_analysis.py not found or not executable${NC}"
                exit 1
            fi
            ;;
        flow-metrics)
            shift
            if [ -x "$SCRIPT_DIR/analysis/flow_metrics.py" ]; then
                python3 "$SCRIPT_DIR/analysis/flow_metrics.py" "$@"
            else
                echo -e "${YELLOW}flow_metrics.py not found or not executable${NC}"
                exit 1
            fi
            ;;
        validate-success)
            shift
            if [ -x "$SCRIPT_DIR/analysis/validate_success_criteria.sh" ]; then
                bash "$SCRIPT_DIR/analysis/validate_success_criteria.sh" "$@"
            else
                echo -e "${YELLOW}validate_success_criteria.sh not found or not executable${NC}"
                exit 1
            fi
            ;;
        validate-dt)
            shift
            if [ -x "$SCRIPT_DIR/analysis/validate_dt_trajectories.py" ]; then
                python3 "$SCRIPT_DIR/analysis/validate_dt_trajectories.py" "$@"
            else
                echo -e "${YELLOW}validate_dt_trajectories.py not found or not executable${NC}"
                exit 1
            fi
            ;;

        help|--help|-h) show_help ;;
        *)
            echo -e "${RED}Unknown command: $1${NC}"
            echo "Run 'af help' for usage"
            exit 1
            ;;
    esac
fi
