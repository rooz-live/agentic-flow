#!/usr/bin/env python3
"""suggest_actions.py

Read recent retro insights and suggest candidate actions.

Design goals:
- Read-only helper for `af suggest-actions`.
- No external dependencies.
- Use `.goalie/insights_log.jsonl` as source of retro_insight entries.
"""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import List, Dict, Any
import sys


def append_observability_action(project_root: Path, ts: str, text: str, depth_level: int, circle: str, focus_tags: List[str]) -> None:
    """Append an observability/logging/metrics gap action to Goalie.

    This is intentionally minimal and avoids external dependencies; it writes a
    small YAML file that other tools (or humans) can promote into Kanban/WSJF
    boards as needed.
    """
    goalie_dir = project_root / ".goalie"
    goalie_dir.mkdir(parents=True, exist_ok=True)
    actions_path = goalie_dir / "OBSERVABILITY_ACTIONS.yaml"

    exists_before = actions_path.exists()

    # Derive a short, safe title from the insight text.
    title = text.strip() or "Observability/logging/metrics gap"
    if len(title) > 80:
        title = title[:77] + "..."
    title_escaped = title.replace("\"", "'")

    safe_ts = (ts or "").replace(" ", "_").replace(":", "").replace("-", "").replace("T", "_").replace("Z", "")
    if not safe_ts:
        safe_ts = "unknown"
    action_id = f"OBS-{safe_ts}"

    tags_json = json.dumps(focus_tags or [])

    with actions_path.open("a", encoding="utf-8") as f:
        if not exists_before:
            f.write("---\n")
            f.write("# Observability / logging / metrics gap actions (auto-generated by suggest_actions.py)\n")
            f.write("items:\n")
        f.write(f"  - id: {action_id}\n")
        f.write(f"    title: \"{title_escaped}\"\n")
        f.write("    category: observability\n")
        f.write("    source: retro_insight\n")
        if ts:
            f.write(f"    timestamp: \"{ts}\"\n")
        f.write(f"    depth: {depth_level}\n")
        if circle:
            f.write(f"    circle: \"{circle}\"\n")
        f.write(f"    tags: {tags_json}\n")
        f.write("\n")


def load_recent_insights(path: Path, limit: int = 20) -> List[Dict[str, Any]]:
    if not path.exists():
        return []

    lines = path.read_text(encoding="utf-8").splitlines()
    if not lines:
        return []

    recent = lines[-limit:]
    results: List[Dict[str, Any]] = []
    for raw in recent:
        raw = raw.strip()
        if not raw:
            continue
        try:
            obj = json.loads(raw)
        except json.JSONDecodeError:
            continue
        if obj.get("type") == "retro_insight":
            results.append(obj)
    return results


def infer_roles(text: str) -> List[str]:
    t = text.lower()
    roles: List[str] = ["Analyst", "Assessor", "Orchestrator"]
    if any(k in t for k in ["docs", "document", "pattern", "design"]):
        roles.extend(["Innovator", "Intuitive"])
    if any(k in t for k in ["risk", "incident", "outage", "security"]):
        roles.append("Seeker")

    seen = set()
    deduped: List[str] = []
    for r in roles:
        if r not in seen:
            seen.add(r)
            deduped.append(r)
    return deduped


def main() -> int:
    script_path = Path(__file__).resolve()
    project_root = script_path.parents[2]
    insights_path = project_root / ".goalie" / "insights_log.jsonl"

    # Depth-aware context from AF (full-cycle or direct suggest-actions invocation)
    circle = os.getenv("AF_CIRCLE", "").strip()
    try:
        depth_level = int(os.getenv("AF_DEPTH_LEVEL", "0"))
    except ValueError:
        depth_level = 0

    depth_labels = {0: "core", 1: "analysis", 2: "circle", 3: "devops", 4: "deploy"}
    depth_label = depth_labels.get(depth_level, "core")

    insights = load_recent_insights(insights_path)
    if not insights:
        sys.stdout.write("No recent retro insights found.\n")
        return 0

    sys.stdout.write(
        f"Suggested actions from recent retro insights (read-only; depth={depth_level} ({depth_label}), circle={circle or '<none>'}):\n\n"
    )

    for obj in insights:
        ts = obj.get("timestamp", "(no timestamp)")
        text = obj.get("text", "(no text)")
        roles = infer_roles(text)

        # Circle perspective can bias ordering
        if circle and circle in roles:
            roles = [circle] + [r for r in roles if r != circle]

        roles_str = ", ".join(roles)
        suggested_title = text.strip()
        if len(suggested_title) > 80:
            suggested_title = suggested_title[:77] + "..."

        # Depth-aware and content-aware focus tags
        t = text.lower()
        focus_tags = ["actionable"]
        if depth_level >= 1:
            focus_tags.append("analysis")
        if depth_level >= 2:
            focus_tags.extend(["review", "retro", "refinement", "replenishment"])
        if depth_level >= 3:
            focus_tags.extend(["technical-radar", "devops", "release-readiness"])
        if depth_level >= 4:
            focus_tags.append("deploy-readiness")

        if any(k in t for k in ["todo", "fixme", "tech debt", "technical debt", "refactor", "cleanup"]):
            focus_tags.append("refactor")
        if any(k in t for k in ["cicd", "ci/cd", "pipeline", "deploy", "deployment", "release", "rollback"]):
            focus_tags.append("cicd")
        if any(k in t for k in ["budget", "cost", "pricing"]):
            focus_tags.append("budgetable")
        if any(k in t for k in ["quick win", "small", "incremental", "mvp"]):
            focus_tags.append("incremental")
        if any(k in t for k in ["focus", "scope", "narrow"]):
            focus_tags.append("focusable")
        if any(k in t for k in ["logging", "logs", "metric", "metrics", "telemetry", "observability", "tracing", "trace", "monitoring", "dashboard"]):
            # Surface observability and logging/metrics gaps as technical-radar items.
            focus_tags.append("technical-radar:logging-metrics")
            focus_tags.append("observability-gap")

        # Deduplicate focus tags while preserving order
        seen = set()
        deduped_focus = []
        for tag in focus_tags:
            if tag not in seen:
                seen.add(tag)
                deduped_focus.append(tag)

        # If this insight surfaces an observability/logging/metrics gap, emit a
        # minimal Goalie action so it shows up in observability-focused views.
        if "observability-gap" in deduped_focus or "technical-radar:logging-metrics" in deduped_focus:
            try:
                append_observability_action(project_root, ts, text, depth_level, circle, deduped_focus)
            except Exception:
                # Keep suggest-actions resilient; action creation is best-effort.
                pass

        sys.stdout.write(f"[{ts}] {text}\n")
        sys.stdout.write(f"  suggested_action: {suggested_title}\n")
        if deduped_focus:
            sys.stdout.write(f"  depth_focus: {', '.join(deduped_focus)}\n")
        sys.stdout.write(f"  suggested_roles: {roles_str}\n\n")

    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
