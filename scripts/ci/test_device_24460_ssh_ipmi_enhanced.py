#!/usr/bin/env python3\n\"\"\"\nEnhanced SSH-based IPMI Monitoring for Device #24460\nWorkaround for DNS resolution failure with neural debugging capabilities\n\"\"\"\n\nimport os\nimport sys\nimport json\nimport time\nimport argparse\nimport subprocess\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\nimport threading\nimport queue\n\n# Neural debugging imports (fallback gracefully)\ntry:\n    import psutil\n    SYSTEM_MONITORING_AVAILABLE = True\nexcept ImportError:\n    SYSTEM_MONITORING_AVAILABLE = False\n    print(\"WARNING: psutil not available, limited system monitoring\")\n\n@dataclass\nclass DeviceStatus:\n    device_id: str\n    timestamp: datetime\n    power_state: str\n    temperature: Optional[float]\n    fan_speed: Optional[int]\n    memory_usage: Optional[float]\n    disk_usage: Optional[float]\n    network_status: str\n    ipmi_accessible: bool\n    ssh_tunnel_active: bool\n    correlation_id: str = \"consciousness-1758658960\"\n\nclass EnhancedIPMIMonitor:\n    def __init__(self, device_id: str = \"24460\", ssh_key_path: str = \"/Users/shahroozbhopti/pem/rooz.pem\"):\n        self.device_id = device_id\n        self.ssh_key_path = Path(ssh_key_path)\n        self.correlation_id = \"consciousness-1758658960\"\n        \n        # Device connection details\n        self.ssh_host = \"hv2b40b82\"\n        self.ssh_user = \"root\"\n        self.ipmi_host = \"23.92.79.2\"  # Direct IP to bypass DNS issues\n        self.backup_hosts = [\"hv2b40b82.hivelocity.net\", \"23.92.79.2\"]\n        \n        # Setup logging\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(levelname)s - %(message)s'\n        )\n        self.logger = logging.getLogger(__name__)\n        \n        # Monitoring state\n        self.ssh_tunnel_pid = None\n        self.monitoring_active = False\n        self.status_queue = queue.Queue()\n        \n    def validate_ssh_key(self) -> bool:\n        \"\"\"Validate SSH key exists and has correct permissions\"\"\"\n        if not self.ssh_key_path.exists():\n            self.logger.error(f\"SSH key not found: {self.ssh_key_path}\")\n            return False\n            \n        # Check permissions (should be 600 or 400)\n        stat_info = self.ssh_key_path.stat()\n        permissions = oct(stat_info.st_mode)[-3:]\n        \n        if permissions not in ['600', '400']:\n            self.logger.warning(f\"SSH key permissions {permissions} may be insecure, recommend 600\")\n            \n        self.logger.info(f\"SSH key validated: {self.ssh_key_path}\")\n        return True\n        \n    def establish_ssh_tunnel(self, local_port: int = 6230) -> bool:\n        \"\"\"Establish SSH tunnel for IPMI access\"\"\"\n        try:\n            # Kill existing tunnel if present\n            self.cleanup_ssh_tunnel()\n            \n            # SSH command with tunnel\n            ssh_cmd = [\n                'ssh',\n                '-i', str(self.ssh_key_path),\n                '-L', f'{local_port}:{self.ipmi_host}:623',  # IPMI port\n                '-N',  # No remote command\n                '-f',  # Background\n                '-o', 'StrictHostKeyChecking=no',\n                '-o', 'UserKnownHostsFile=/dev/null',\n                '-o', 'ServerAliveInterval=60',\n                '-o', 'ServerAliveCountMax=3',\n                f'{self.ssh_user}@{self.ssh_host}'\n            ]\n            \n            self.logger.info(f\"Establishing SSH tunnel: {' '.join(ssh_cmd)}\")\n            \n            result = subprocess.run(\n                ssh_cmd,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            \n            if result.returncode == 0:\n                # Find SSH process PID\n                time.sleep(2)  # Allow tunnel to establish\n                self.ssh_tunnel_pid = self.find_ssh_tunnel_pid(local_port)\n                \n                if self.ssh_tunnel_pid:\n                    self.logger.info(f\"SSH tunnel established successfully, PID: {self.ssh_tunnel_pid}\")\n                    return True\n                else:\n                    self.logger.error(\"SSH tunnel process not found after establishment\")\n                    return False\n            else:\n                self.logger.error(f\"SSH tunnel failed: {result.stderr}\")\n                return False\n                \n        except subprocess.TimeoutExpired:\n            self.logger.error(\"SSH tunnel establishment timed out\")\n            return False\n        except Exception as e:\n            self.logger.error(f\"SSH tunnel error: {e}\")\n            return False\n            \n    def find_ssh_tunnel_pid(self, local_port: int) -> Optional[int]:\n        \"\"\"Find SSH tunnel process PID\"\"\"\n        try:\n            # Look for SSH process with our tunnel\n            result = subprocess.run(\n                ['pgrep', '-f', f'ssh.*-L.*{local_port}'],\n                capture_output=True,\n                text=True\n            )\n            \n            if result.returncode == 0 and result.stdout.strip():\n                pid = int(result.stdout.strip().split('\\n')[0])\n                return pid\n                \n        except Exception as e:\n            self.logger.debug(f\"PID search failed: {e}\")\n            \n        return None\n        \n    def cleanup_ssh_tunnel(self):\n        \"\"\"Clean up SSH tunnel process\"\"\"\n        if self.ssh_tunnel_pid:\n            try:\n                os.kill(self.ssh_tunnel_pid, 9)\n                self.logger.info(f\"SSH tunnel cleaned up, PID: {self.ssh_tunnel_pid}\")\n                self.ssh_tunnel_pid = None\n            except OSError:\n                self.logger.debug(\"SSH tunnel process already terminated\")\n                \n    def test_ipmi_access(self, local_port: int = 6230) -> Tuple[bool, Dict]:\n        \"\"\"Test IPMI access through SSH tunnel\"\"\"\n        ipmi_data = {\n            'accessible': False,\n            'power_state': 'unknown',\n            'temperature': None,\n            'fan_speed': None,\n            'error': None\n        }\n        \n        try:\n            # Test basic IPMI connectivity\n            ipmi_cmd = [\n                'ipmitool',\n                '-I', 'lanplus',\n                '-H', '127.0.0.1',\n                '-p', str(local_port),\n                '-U', 'ADMIN',  # Common IPMI username\n                '-P', 'ADMIN',  # Common IPMI password - should be secured\n                'power', 'status'\n            ]\n            \n            result = subprocess.run(\n                ipmi_cmd,\n                capture_output=True,\n                text=True,\n                timeout=15\n            )\n            \n            if result.returncode == 0:\n                power_output = result.stdout.strip()\n                ipmi_data['accessible'] = True\n                ipmi_data['power_state'] = 'on' if 'on' in power_output.lower() else 'off'\n                \n                # Get additional sensor data\n                sensor_data = self.get_sensor_data(local_port)\n                ipmi_data.update(sensor_data)\n                \n                self.logger.info(f\"IPMI access successful: {power_output}\")\n                return True, ipmi_data\n            else:\n                error_msg = result.stderr or \"Unknown IPMI error\"\n                ipmi_data['error'] = error_msg\n                self.logger.error(f\"IPMI command failed: {error_msg}\")\n                return False, ipmi_data\n                \n        except subprocess.TimeoutExpired:\n            ipmi_data['error'] = \"IPMI command timed out\"\n            self.logger.error(\"IPMI command timed out\")\n            return False, ipmi_data\n        except FileNotFoundError:\n            ipmi_data['error'] = \"ipmitool not found - install with: brew install ipmitool\"\n            self.logger.error(\"ipmitool not available\")\n            return False, ipmi_data\n        except Exception as e:\n            ipmi_data['error'] = str(e)\n            self.logger.error(f\"IPMI test error: {e}\")\n            return False, ipmi_data\n            \n    def get_sensor_data(self, local_port: int) -> Dict:\n        \"\"\"Get additional sensor data from IPMI\"\"\"\n        sensor_data = {\n            'temperature': None,\n            'fan_speed': None\n        }\n        \n        try:\n            # Get temperature sensors\n            temp_cmd = [\n                'ipmitool',\n                '-I', 'lanplus',\n                '-H', '127.0.0.1',\n                '-p', str(local_port),\n                '-U', 'ADMIN',\n                '-P', 'ADMIN',\n                'sdr', 'type', 'temperature'\n            ]\n            \n            result = subprocess.run(\n                temp_cmd,\n                capture_output=True,\n                text=True,\n                timeout=10\n            )\n            \n            if result.returncode == 0:\n                # Parse temperature from output\n                for line in result.stdout.split('\\n'):\n                    if 'degrees C' in line and '|' in line:\n                        parts = line.split('|')\n                        if len(parts) >= 2:\n                            temp_str = parts[1].strip().replace('degrees C', '').strip()\n                            try:\n                                sensor_data['temperature'] = float(temp_str)\n                                break\n                            except ValueError:\n                                continue\n                                \n            # Get fan speed\n            fan_cmd = temp_cmd[:-2] + ['fan']\n            result = subprocess.run(\n                fan_cmd,\n                capture_output=True,\n                text=True,\n                timeout=10\n            )\n            \n            if result.returncode == 0:\n                # Parse fan speed from output\n                for line in result.stdout.split('\\n'):\n                    if 'RPM' in line and '|' in line:\n                        parts = line.split('|')\n                        if len(parts) >= 2:\n                            rpm_str = parts[1].strip().replace('RPM', '').strip()\n                            try:\n                                sensor_data['fan_speed'] = int(rpm_str)\n                                break\n                            except ValueError:\n                                continue\n                                \n        except Exception as e:\n            self.logger.debug(f\"Sensor data collection failed: {e}\")\n            \n        return sensor_data\n        \n    def neural_system_analysis(self) -> Dict:\n        \"\"\"Neural debugging - analyze system state\"\"\"\n        analysis = {\n            'status': 'disabled',\n            'system_load': None,\n            'memory_usage': None,\n            'network_connections': 0,\n            'ssh_processes': 0\n        }\n        \n        if not SYSTEM_MONITORING_AVAILABLE:\n            return analysis\n            \n        try:\n            # System resource usage\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory = psutil.virtual_memory()\n            \n            # Network connections\n            connections = psutil.net_connections()\n            ssh_connections = [c for c in connections if c.laddr and c.laddr.port == 22]\n            \n            # SSH processes\n            ssh_processes = []\n            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):\n                try:\n                    if proc.info['name'] == 'ssh' and proc.info['cmdline']:\n                        cmdline = ' '.join(proc.info['cmdline'])\n                        if self.ssh_host in cmdline or 'tunnel' in cmdline:\n                            ssh_processes.append(proc.info)\n                except (psutil.NoSuchProcess, psutil.AccessDenied):\n                    continue\n                    \n            analysis.update({\n                'status': 'completed',\n                'cpu_usage': cpu_percent,\n                'memory_usage': memory.percent,\n                'memory_available_gb': memory.available / (1024**3),\n                'network_connections': len(connections),\n                'ssh_connections': len(ssh_connections),\n                'ssh_processes': len(ssh_processes),\n                'ssh_process_details': ssh_processes\n            })\n            \n        except Exception as e:\n            analysis['status'] = 'error'\n            analysis['error'] = str(e)\n            \n        return analysis\n        \n    def comprehensive_health_check(self) -> DeviceStatus:\n        \"\"\"Perform comprehensive device health check\"\"\"\n        start_time = datetime.now()\n        \n        # Validate SSH key\n        ssh_key_valid = self.validate_ssh_key()\n        \n        # Establish SSH tunnel\n        tunnel_success = False\n        if ssh_key_valid:\n            tunnel_success = self.establish_ssh_tunnel()\n        \n        # Test IPMI access\n        ipmi_accessible = False\n        ipmi_data = {}\n        if tunnel_success:\n            ipmi_accessible, ipmi_data = self.test_ipmi_access()\n            \n        # Neural system analysis\n        neural_analysis = self.neural_system_analysis()\n        \n        # Create device status\n        status = DeviceStatus(\n            device_id=self.device_id,\n            timestamp=start_time,\n            power_state=ipmi_data.get('power_state', 'unknown'),\n            temperature=ipmi_data.get('temperature'),\n            fan_speed=ipmi_data.get('fan_speed'),\n            memory_usage=neural_analysis.get('memory_usage'),\n            disk_usage=None,  # Would need additional SSH commands\n            network_status='connected' if tunnel_success else 'disconnected',\n            ipmi_accessible=ipmi_accessible,\n            ssh_tunnel_active=tunnel_success,\n            correlation_id=self.correlation_id\n        )\n        \n        return status\n        \n    def emit_heartbeat(self, status: DeviceStatus, neural_analysis: Dict):\n        \"\"\"Emit heartbeat for telemetry continuity\"\"\"\n        heartbeat = {\n            'timestamp': datetime.now().isoformat(),\n            'correlation_id': self.correlation_id,\n            'event': 'device_health_check_completed',\n            'device_status': {\n                'device_id': status.device_id,\n                'power_state': status.power_state,\n                'temperature': status.temperature,\n                'ipmi_accessible': status.ipmi_accessible,\n                'ssh_tunnel_active': status.ssh_tunnel_active,\n                'network_status': status.network_status\n            },\n            'neural_analysis': neural_analysis\n        }\n        \n        # Write to shared log for unified telemetry\n        heartbeat_log = Path('logs/master_orchestrator.log')\n        heartbeat_log.parent.mkdir(exist_ok=True)\n        \n        with open(heartbeat_log, 'a') as f:\n            f.write(f\"HEARTBEAT: {json.dumps(heartbeat)}\\n\")\n            \n        # Also write to device-specific log\n        device_log = Path(f'logs/device_{self.device_id}_monitoring.log')\n        device_log.parent.mkdir(exist_ok=True)\n        \n        with open(device_log, 'a') as f:\n            f.write(f\"{datetime.now().isoformat()} - {json.dumps(heartbeat)}\\n\")\n            \n        self.logger.info(f\"Heartbeat emitted for device {self.device_id}\")\n        \n    def save_status_report(self, status: DeviceStatus, neural_analysis: Dict, output_file: str = None):\n        \"\"\"Save comprehensive status report\"\"\"\n        if output_file is None:\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            output_file = f'device_{self.device_id}_status_{timestamp}.json'\n            \n        report = {\n            'metadata': {\n                'correlation_id': self.correlation_id,\n                'device_id': self.device_id,\n                'check_timestamp': status.timestamp.isoformat(),\n                'ssh_key_path': str(self.ssh_key_path),\n                'ssh_host': self.ssh_host,\n                'ipmi_host': self.ipmi_host\n            },\n            'device_status': {\n                'power_state': status.power_state,\n                'temperature_celsius': status.temperature,\n                'fan_speed_rpm': status.fan_speed,\n                'memory_usage_percent': status.memory_usage,\n                'network_status': status.network_status,\n                'ipmi_accessible': status.ipmi_accessible,\n                'ssh_tunnel_active': status.ssh_tunnel_active\n            },\n            'neural_analysis': neural_analysis,\n            'recommendations': self.generate_recommendations(status, neural_analysis)\n        }\n        \n        output_path = Path('reports') / output_file\n        output_path.parent.mkdir(exist_ok=True)\n        \n        with open(output_path, 'w') as f:\n            json.dump(report, f, indent=2, default=str)\n            \n        self.logger.info(f\"Status report saved to: {output_path}\")\n        return str(output_path)\n        \n    def generate_recommendations(self, status: DeviceStatus, neural_analysis: Dict) -> List[str]:\n        \"\"\"Generate actionable recommendations\"\"\"\n        recommendations = []\n        \n        # IPMI accessibility\n        if not status.ipmi_accessible:\n            recommendations.append(\"CRITICAL: IPMI not accessible - verify network connectivity and credentials\")\n            \n        # SSH tunnel\n        if not status.ssh_tunnel_active:\n            recommendations.append(\"HIGH: SSH tunnel failed - check SSH key permissions and network connectivity\")\n            \n        # Temperature monitoring\n        if status.temperature and status.temperature > 80:\n            recommendations.append(f\"WARNING: High temperature detected ({status.temperature}°C) - check cooling\")\n        elif status.temperature and status.temperature > 70:\n            recommendations.append(f\"CAUTION: Elevated temperature ({status.temperature}°C) - monitor closely\")\n            \n        # System resources\n        if neural_analysis.get('memory_usage', 0) > 90:\n            recommendations.append(f\"WARNING: High memory usage ({neural_analysis['memory_usage']:.1f}%) - investigate processes\")\n            \n        # Power state\n        if status.power_state == 'off':\n            recommendations.append(\"ALERT: Device powered off - verify intentional shutdown\")\n        elif status.power_state == 'unknown':\n            recommendations.append(\"INVESTIGATE: Power state unknown - IPMI communication issue\")\n            \n        if not recommendations:\n            recommendations.append(\"HEALTHY: All monitored parameters within normal ranges\")\n            \n        return recommendations\n        \n    def __del__(self):\n        \"\"\"Cleanup on object destruction\"\"\"\n        self.cleanup_ssh_tunnel()\n\ndef main():\n    parser = argparse.ArgumentParser(description='Enhanced SSH-based IPMI monitoring for device #24460')\n    parser.add_argument('--device-id', default='24460', help='Device ID to monitor')\n    parser.add_argument('--ssh-key', default='/Users/shahroozbhopti/pem/rooz.pem', help='SSH private key path')\n    parser.add_argument('--ssh-host', default='hv2b40b82', help='SSH host for tunnel')\n    parser.add_argument('--ipmi-host', default='23.92.79.2', help='IPMI host IP')\n    parser.add_argument('--output-file', help='Output report filename')\n    parser.add_argument('--neural', action='store_true', help='Enable neural system analysis')\n    parser.add_argument('--continuous', action='store_true', help='Continuous monitoring mode')\n    parser.add_argument('--interval', type=int, default=300, help='Monitoring interval in seconds')\n    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose logging')\n    \n    args = parser.parse_args()\n    \n    if args.verbose:\n        logging.getLogger().setLevel(logging.DEBUG)\n        \n    # Initialize monitor\n    monitor = EnhancedIPMIMonitor(\n        device_id=args.device_id,\n        ssh_key_path=args.ssh_key\n    )\n    \n    # Update hosts if provided\n    if args.ssh_host != 'hv2b40b82':\n        monitor.ssh_host = args.ssh_host\n    if args.ipmi_host != '23.92.79.2':\n        monitor.ipmi_host = args.ipmi_host\n        \n    try:\n        if args.continuous:\n            print(f\"Starting continuous monitoring of device {args.device_id} (interval: {args.interval}s)\")\n            print(\"Press Ctrl+C to stop...\")\n            \n            while True:\n                # Perform health check\n                status = monitor.comprehensive_health_check()\n                neural_analysis = monitor.neural_system_analysis() if args.neural else {}\n                \n                # Emit heartbeat\n                monitor.emit_heartbeat(status, neural_analysis)\n                \n                # Print status\n                print(f\"\\n=== Device {args.device_id} Status - {status.timestamp.strftime('%Y-%m-%d %H:%M:%S')} ===\")\n                print(f\"Power State: {status.power_state}\")\n                print(f\"IPMI Accessible: {status.ipmi_accessible}\")\n                print(f\"SSH Tunnel: {status.ssh_tunnel_active}\")\n                print(f\"Network: {status.network_status}\")\n                if status.temperature:\n                    print(f\"Temperature: {status.temperature}°C\")\n                if status.fan_speed:\n                    print(f\"Fan Speed: {status.fan_speed} RPM\")\n                    \n                time.sleep(args.interval)\n                \n        else:\n            # Single health check\n            print(f\"Performing health check on device {args.device_id}...\")\n            \n            status = monitor.comprehensive_health_check()\n            neural_analysis = monitor.neural_system_analysis() if args.neural else {}\n            \n            # Save report\n            report_path = monitor.save_status_report(status, neural_analysis, args.output_file)\n            \n            # Emit heartbeat\n            monitor.emit_heartbeat(status, neural_analysis)\n            \n            # Print results\n            print(f\"\\n=== Device {args.device_id} Health Check Results ===\")\n            print(f\"Device ID: {status.device_id}\")\n            print(f\"Check Time: {status.timestamp}\")\n            print(f\"Power State: {status.power_state}\")\n            print(f\"IPMI Accessible: {status.ipmi_accessible}\")\n            print(f\"SSH Tunnel Active: {status.ssh_tunnel_active}\")\n            print(f\"Network Status: {status.network_status}\")\n            \n            if status.temperature:\n                print(f\"Temperature: {status.temperature}°C\")\n            if status.fan_speed:\n                print(f\"Fan Speed: {status.fan_speed} RPM\")\n            if status.memory_usage:\n                print(f\"Memory Usage: {status.memory_usage:.1f}%\")\n                \n            if neural_analysis.get('status') == 'completed':\n                print(f\"\\nSystem Analysis:\")\n                print(f\"  CPU Usage: {neural_analysis.get('cpu_usage', 'N/A')}%\")\n                print(f\"  Memory Available: {neural_analysis.get('memory_available_gb', 'N/A'):.1f} GB\")\n                print(f\"  SSH Processes: {neural_analysis.get('ssh_processes', 0)}\")\n                \n            # Recommendations\n            recommendations = monitor.generate_recommendations(status, neural_analysis)\n            if recommendations:\n                print(f\"\\nRecommendations:\")\n                for rec in recommendations:\n                    print(f\"  • {rec}\")\n                    \n            print(f\"\\nReport saved to: {report_path}\")\n            \n            # Exit code based on health\n            if not status.ipmi_accessible or not status.ssh_tunnel_active:\n                print(\"\\nWARNING: Critical monitoring capabilities compromised\")\n                sys.exit(2)\n            elif status.power_state == 'off':\n                print(\"\\nCAUTION: Device powered off\")\n                sys.exit(1)\n            else:\n                print(\"\\nSUCCESS: Device monitoring operational\")\n                sys.exit(0)\n                \n    except KeyboardInterrupt:\n        print(\"\\nMonitoring stopped by user\")\n        sys.exit(0)\n    except Exception as e:\n        print(f\"\\nERROR: Monitoring failed - {e}\")\n        sys.exit(3)\n    finally:\n        # Cleanup\n        monitor.cleanup_ssh_tunnel()\n\nif __name__ == '__main__':\n    main()